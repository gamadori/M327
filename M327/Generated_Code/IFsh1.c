/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : IFsh1.c
**     Project     : M327
**     Processor   : MC56F84789VLL
**     Component   : IntFLASH
**     Version     : Component 02.409, Driver 01.01, CPU db: 3.50.001
**     Compiler    : CodeWarrior DSP C Compiler
**     Date/Time   : 2016-11-16, 17:56, # CodeGen: 171
**     Abstract    :
**         This component "IntFLASH" implements an access to internal FLASH.
**         The component support reading/writing data into FLASH, erasing of
**         selected sector.
**         The component supports events if the write interrupt is supported.
**         The component supports following modes of write operations:
**           - Write - writing without any test.
**           - Destructive write - sector is erased if necessary.
**           - Safe write - user event is invoked to save and resore data
**                          from the current sector.
**         The component requires on-chip FLASH memory (not used/allocated by
**         other components).
**     Settings    :
**         FLASH memory type                 : Data FLASH
**         Memory size                       : 16384 words
**         Sector size                       : 512 words
**         Interrupt service                 : Enabled
**         Write method                      : Safe write (with save & erase)
**         Buffer Type                       : Implemented by the component
**         Wait in RAM                       : yes
**     Contents    :
**         DisableEvent - byte IFsh1_DisableEvent(void);
**         EnableEvent  - byte IFsh1_EnableEvent(void);
**         Busy         - bool IFsh1_Busy(byte Block);
**         SetByteFlash - byte IFsh1_SetByteFlash(IFsh1_TAddress Addr, byte Data);
**         GetByteFlash - byte IFsh1_GetByteFlash(IFsh1_TAddress Addr, byte *Data);
**         SetWordFlash - byte IFsh1_SetWordFlash(IFsh1_TAddress Addr, word Data);
**         GetWordFlash - byte IFsh1_GetWordFlash(IFsh1_TAddress Addr, word *Data);
**         SetLongFlash - byte IFsh1_SetLongFlash(IFsh1_TAddress Addr, dword Data);
**         GetLongFlash - byte IFsh1_GetLongFlash(IFsh1_TAddress Addr, dword *Data);
**         DataPtr2Addr - IFsh1_TAddress IFsh1_DataPtr2Addr(void* Addr);
**         FuncPtr2Addr - IFsh1_TAddress IFsh1_FuncPtr2Addr(void(*Addr)());
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file IFsh1.c
** @version 01.01
** @brief
**         This component "IntFLASH" implements an access to internal FLASH.
**         The component support reading/writing data into FLASH, erasing of
**         selected sector.
**         The component supports events if the write interrupt is supported.
**         The component supports following modes of write operations:
**           - Write - writing without any test.
**           - Destructive write - sector is erased if necessary.
**           - Safe write - user event is invoked to save and resore data
**                          from the current sector.
**         The component requires on-chip FLASH memory (not used/allocated by
**         other components).
*/         
/*!
**  @addtogroup IFsh1_module IFsh1 module documentation
**  @{
*/         
/* MODULE IFsh1. */

#include "Events.h"
#include "IFsh1.h"

volatile static byte Err;              /* Error state of current process */
volatile static bool EnEvent;          /* Enable/Disable events */
volatile static bool EnWriteEnd;       /* Enable/Disable call write end events */
static word BackupArray[DATA_FLASH_SECTOR_SIZE]; /* Array for backup data from erased sector */


static word readflash(IFsh1_TAddress address);
static void procflash(IFsh1_TAddress Address, dword Data, byte Command);

/*
** ===================================================================
**     Method      :  IFsh1_OutOfRange (component IntFLASH)
**
**     Description :
**         The method returns FALSE, if both of the input parameters are 
**         in an allowed flash memory address range. If at least one of 
**         the parameters is out of the range, return TRUE.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool OutOfRange(IFsh1_TAddress addr1,IFsh1_TAddress addr2)
{
  return (bool)(((addr1 > addr2)||(addr1 < DATA_FLASH_START)||(addr2 > DATA_FLASH_END))? TRUE:FALSE);
}

/*
** ===================================================================
**     Method      :  IFsh1_BackupArrayAddr (component IntFLASH)
**
**     Description :
**         The method converts a flash memory address to an address in 
**         the backup array for saving the data before erasing a sector 
**         in Save write mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define BackupArrayAddr(addr) (addr & 0x01FFU)

/*
** ===================================================================
**     Method      :  IFsh1_SectorSize (component IntFLASH)
**
**     Description :
**         The method returns flash memory sector (erase page) size of a 
**         desired area.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define SectorSize(addr) (DATA_FLASH_SECTOR_SIZE)

/*
** ===================================================================
**     Method      :  ClearFlags (component IntFLASH)
**
**     Description :
**         The method clears the flash memory interface complete and 
**         error flags.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

/*
** ===================================================================
**     Method      :  readflash (component IntFLASH)
**
**     Description :
**         The method reads 16-bit word from a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define readflash(address) (*(word *)(address))

/*
** ===================================================================
**     Method      :  Run_and_wait_in_prog_flash (component IntFLASH)
**
**     Description :
**         This method runs programming or erasing process end waits 
**         until it ends. This routine is placed in program flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma define_section RAW_PROG_FLASH_section ".RAW_PROG_FLASH" RX
#pragma section RAW_PROG_FLASH_section begin
/*lint -save  -e586 Disable MISRA rule (2.1) checking. */
static asm void Run_and_wait_in_prog_flash(void)
{
  move.l #0x0001C780,R0
  move.w #0x80,A
  move.bp A1,X:(R0)                    /* Launch the command */
wait:
  move.l #0x0001C780,R0
  moveu.bp X:(R0),A
  zxt.b A,A
  bftstl #0x80,A1
  bcs wait                             /* Wait to command complete */
  nop
  nop
  rts
}
/*lint -restore Enable MISRA rule (2.1) checking. */
#pragma section RAW_PROG_FLASH_section end

/*
** ===================================================================
**     Method      :  Run_and_wait_in_RAM (component IntFLASH)
**
**     Description :
**         This method runs programming or erasing process end waits 
**         until it ends. This routine is placed in RAM.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma define_section RAW_RAM_section ".RAW_RAM" RWX
#pragma section RAW_RAM_section begin
/*lint -save  -e586 Disable MISRA rule (2.1) checking. */
static asm void Run_and_wait_in_RAM(void)
{
  move.l #0x0001C780,R0
  move.w #0x80,A
  move.bp A1,X:(R0)                    /* Launch the command */
wait:
  move.l #0x0001C780,R0
  moveu.bp X:(R0),A
  zxt.b A,A
  bftstl #0x80,A1
  bcs wait                             /* Wait to command complete */
  nop
  nop
  rts
}
/*lint -restore Enable MISRA rule (2.1) checking. */
#pragma section RAW_RAM_section end

/*
** ===================================================================
**     Method      :  mempcpy (component IntFLASH)
**
**     Description :
**         The methods makes a copy of a program memory block (both 
**         source and destination address is in a program memory). It is 
**         used for copying the WIR_routine / Run_and_wait_in_RAM routine 
**         to RAM after system reset.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*lint -save  -e586 Disable MISRA rule (2.1) checking. */
static asm void mempcpy(IFsh1_TAddress source_addr, IFsh1_TAddress dest_addr, word size)
{
    move.w  y0,r2                      /* set data size */
    move.l  a10,r3                     /* src address */
    move.l  b10,r1                     /* dest address */
    do      r2,>>end_prom2pram         /* copy for r2 times */
    move.w  p:(r3)+,x0                 /* fetch value at address r3 */
    nop
    nop
    nop
    move.w  x0,p:(r1)+                 /* stash value at address r1 */
    nop
    nop
    nop
end_prom2pram:
    rts
}
/*lint -restore Enable MISRA rule (2.1) checking. */

/*
** ===================================================================
**     Method      :  procflash (component IntFLASH)
**
**     Description :
**         The method programs 16-bit word to a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void procflash(IFsh1_TAddress Address, dword Data, byte Command)
{
  if (IFsh1_Busy()) {                  /* Is a command in progress in any of the flash devices? */
    Err = ERR_BUSY;                    /* If yes then set error */
    return;
  }
  *((dword *)(void *)&FTFL_FCCOB3) = (dword)(((Address - DATA_FLASH_START) << 1) | (1UL << 23)); /* Set data flash address value */
  *((dword *)(void *)&FTFL_FCCOB7) = Data; /* Set data/parameter value */
  setReg8(FTFL_FCCOB0, Command);       /* Write given command to Command register */
  EnterCritical();                     /* Disable all low level interrupts */
  Run_and_wait_in_RAM();               /* Process routine in RAM */
  ExitCritical();                      /* Enable all low level interrupts */
  setReg8Bit(FTFL_FCNFG, CCIE);        /* Enable interrupt */
}

/*
** ===================================================================
**     Method      :  BackupSector (component IntFLASH)
**
**     Description :
**         The method backups data from a sector, which is to be erased 
**         in the Save write mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void BackupSector(IFsh1_TAddress Addr)
{
  register word i;
  register IFsh1_TAddress StartAddress;

  StartAddress = (IFsh1_TAddress)(Addr & (IFsh1_TAddress)~((IFsh1_TAddress)(SectorSize(Addr)-1U))); /* Calculate start of the sector */
  for (i=SectorSize(Addr); i > 0U;) {  /* For all words in the sector */
    i--;                               /* array pointer */
    BackupArray[i] = readflash((StartAddress+i)); /* save word to buffer in data RAM */
  }
}

/*
** ===================================================================
**     Method      :  RestoreSector (component IntFLASH)
**
**     Description :
**         The method restores data to a sector, which has been erased in 
**         the Save write mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte RestoreSector(IFsh1_TAddress Addr)
{
  register word i = 0x00U;
  register word tmpData;
  register IFsh1_TAddress StartAddress;

  StartAddress = (Addr & (IFsh1_TAddress)~((IFsh1_TAddress)(SectorSize(Addr) - 1U))); /* Calculate start of the sector */
  for (i = SectorSize(Addr); i > 0U;) { /* For all words in the sector */
    i--;                               /* Decrease array pointer, write word to FLASH */
    if (((StartAddress+i) & 0x01U) == 0x00U) {
      tmpData = readflash((StartAddress+i) + 1U);
      procflash((StartAddress+i), (dword)(((dword)tmpData << 16) | BackupArray[i]), PROGRAM); /* Write new data to Flash */
    } else {
      tmpData = readflash((StartAddress+i) - 1U);
      procflash(((StartAddress+i) - 1U), (dword)(tmpData  | ((dword)BackupArray[i] << 16)), PROGRAM); /* Write new data to Flash */
    }
    while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
    if (Err != ERR_OK) {               /* If an error uccure then exit */
      return Err;
    }
  }
  while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
  for (i = SectorSize(Addr); i > 0U;) { /* For all words in the sector */
    i--;                               /* Decrease array pointer, write word to FLASH */
    if (readflash((StartAddress+i)) != BackupArray[i]) { /* Are the written data equal to read data ? */
      return ERR_VALUE;                /* If no then error */
    }
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  WriteWords (component IntFLASH)
**
**     Description :
**         The method writes block of 16-bit words to a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteWords(IFsh1_TAddress Addr, word* PData, dword Size)
{
  register word i;
  register word* tmpPData = PData;
  register bool SectorBackup;
  register word j, cycles, AddrInSec;
  register word tmpData;

  Err = ERR_OK;
  j = 0U;
  cycles = 0U;
  if (OutOfRange(Addr, (Addr + Size) - 1U)) { /* Is the address out of range? */
    return ERR_RANGE;                  /* If yes then exit */
  }
  SectorBackup = FALSE;                /* Initialize sector backup flag */
  for (i = 0U; i < Size; i++) {        /* For all given data */
    AddrInSec = (word)((Addr+i)&((dword)SectorSize(Addr+i)-1U)); /* Calculate relative address in a sector */
    if ((AddrInSec == 0U) || (i == 0U)) { /* Is the actual address the first or is it a border of a sector? */
      cycles = (word)((SectorSize(Addr+i) - AddrInSec) - /* How many address places have to be testet in the actual sector? */
               (((dword)(Size - i) < (dword)(SectorSize(Addr+i) - AddrInSec)) ? ((SectorSize(Addr + 1U) - AddrInSec) - (Size + i)) : 0U));
      while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
      for (j = 0U; j < cycles; j++) {  /* For all memory locations which have to be tested in the actual sector */
        if (((word)~(readflash(Addr+i+j)) & (tmpPData[i+j])) != 0x00U) { /* Is the sector erasure necessary? */
           BackupSector(Addr + i);     /* Backup the sector */
           SectorBackup = TRUE;        /* Set backup sector flag */
          procflash(((Addr+i) & 0xFFFFFFFCU), 0U, PAGE_ERASE); /* Erase the sector */
          while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
          if (Err != ERR_OK) {         /* If an error occured then exit */
            return Err;
          }
          break;                       /* The sector is backuped and erased. Now end test of the sector */
        }
      }
      j = 0U;                          /* Initialize sector memory location index */
    }
    if (SectorBackup) {                /* If the sector is backuped, write new data to buffer */
      BackupArray[AddrInSec] = tmpPData[i];
    } else {                           /* If no, write data directly to FLASH */
      while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
      if (readflash(Addr+i) != tmpPData[i]) { /* Is a programming of the FLASH necessary? */
        if (((Addr+i) & 0x01U) == 0x00U) {
          tmpData = readflash((Addr+i) + 1U);
          procflash((Addr+i), (dword)(((dword)tmpData << 16) | tmpPData[i]), PROGRAM); /* Write new data to Flash */
        } else {
          tmpData = readflash((Addr+i) - 1U);
          procflash(((Addr+i) - 1U), (dword)(tmpData  | ((dword)tmpPData[i] << 16)), PROGRAM); /* Write new data to Flash */
        }
      }
      while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
      if (Err != ERR_OK) {             /* If an error occured then exit */
        return Err;
      }
    }
    j++;                               /* Increment the sector index */
    if ((j == cycles) && (SectorBackup)) { /* Is the actual sector memory location the last and is the sector backuped? */
      Err = RestoreSector(Addr + i);   /* Restore actual sector */
      SectorBackup = FALSE;            /* Clear sector backup flag */
    }
    if (Err!=ERR_OK) {                 /* If an error occured then exit */
      return Err;
    }
  }
  while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
  for (i = 0U; i < Size; i++) {        /* Check all given data were written good */
    if (readflash(Addr+i) != tmpPData[i]) {
      return ERR_VALUE;                /* If an error occurred exit */
    }
  }
  EnWriteEnd = TRUE;                   /* Enable call WriteEnd event */
  setReg8Bit(FTFL_FCNFG, CCIE);        /* Enable interrupt */
  return Err;
}

/*
** ===================================================================
**     Method      :  IFsh1_DisableEvent (component IntFLASH)
*/
/*!
**     @brief
**         This method disables all the events except [OnSaveBuffer],
**         [OnRestoreBuffer] and [OnEraseError]. The method is
**         available only if any event is enabled.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode
*/
/* ===================================================================*/
byte IFsh1_DisableEvent(void)
{
  EnEvent = FALSE;                     /* Set the flag "events disabled" */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  IFsh1_EnableEvent (component IntFLASH)
*/
/*!
**     @brief
**         This method enables all the events except [OnSaveBuffer],
**         [OnRestoreBuffer] and [OnEraseError]. The method is
**         available only if any event is enabled.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode
*/
/* ===================================================================*/
byte IFsh1_EnableEvent(void)
{
  EnEvent = TRUE;                      /* Set the flag "events enabled" */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  IFsh1_Busy (component IntFLASH)
*/
/*!
**     @brief
**         This method returns the status of the FLASH device. The
**         method may be required and called from another component
**         methods - in this case it cannot be disabled.
**     @param
**         Block           - Number of Flash block. Not used for
**                           Freescale 56800, HCS08, HCS12X and
**                           ColdFireV1 derivates - any value may be
**                           passed.
**     @return
**                         - [true]/[false] - FLASH is busy/ready
*/
/* ===================================================================*/
/*
bool IFsh1_Busy(byte Block)

**      This method is implemented as macro. See IFsh1.h file.      **
*/

/*
** ===================================================================
**     Method      :  IFsh1_SetByteFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a byte to an address in FLASH. The operation of this
**         method depends on the "Write method" property and state of
**         the flash. Please see more details on general info page of
**         the help.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           byte location in the selected memory space
**                           (address of a 16 bit word location
**                           multiplied by 2 and the least significant
**                           bit determines even or odd byte). The
**                           memory space depends on the selected flash
**                           memory device.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_VALUE - Read value is not equal to
**                           written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetByteFlash(IFsh1_TAddress Addr, byte Data)
{
  register IFsh1_TAddress Addr16;
  word Data16;
  byte rot;

  Addr16 = (Addr >> 1);                /* Determine WORD16 address */
  rot = (byte)((Addr % 2U) * 8U);
  Data16 = (readflash(Addr16) & ((word)0xFF00U >> rot)) + (((word)Data & 0xFFU) << rot);
  return WriteWords(Addr16, &Data16, sizeof(Data16)/sizeof(word)); /* Write data to FLASH - use block method */
}

/*
** ===================================================================
**     Method      :  IFsh1_GetByteFlash (component IntFLASH)
*/
/*!
**     @brief
**         Gets byte from an address in FLASH.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           byte location in the selected memory space
**                           (address of a 16 bit word location
**                           multiplied by 2 and the least significant
**                           bit determines even or odd byte). The
**                           memory space depends on the selected flash
**                           memory device.
**     @param
**         Data            - A pointer to the returned 8-bit data.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_BUSY - Device is busy
*/
/* ===================================================================*/
byte IFsh1_GetByteFlash(IFsh1_TAddress Addr,byte *Data)
{
  word Data16;

  if (OutOfRange((Addr / 2U), (Addr / 2U))) { /* Check range of address */
    return ERR_RANGE;
  }
  Data16 = readflash((Addr / 2U));     /* Read word from FLASH */
  *Data = (byte)((Addr % 2U)?(Data16 >> 8):(Data16 & 0xFFU));
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_SetWordFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a word to an address in FLASH. The operation of this
**         method depends on the "Write method" property and state of
**         the flash. Please see more details on general info page of
**         the help.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           16 bit word location in the selected memory
**                           space. The memory space depends on the
**                           selected flash memory device.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_VALUE - Read value is not equal to
**                           written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetWordFlash(IFsh1_TAddress Addr,word Data)
{
  return WriteWords(Addr, &Data, sizeof(Data)/sizeof(word)); /* Write data to FLASH - use block method */
}

/*
** ===================================================================
**     Method      :  IFsh1_GetWordFlash (component IntFLASH)
*/
/*!
**     @brief
**         Gets a word from an address in FLASH.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           16 bit word location in the selected memory
**                           space. The memory space depends on the
**                           selected flash memory device.
**     @param
**         Data            - A pointer to the returned 16-bit data.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_BUSY - Device is busy
*/
/* ===================================================================*/
byte IFsh1_GetWordFlash(IFsh1_TAddress Addr,word *Data)
{
  if (OutOfRange(Addr, Addr)) {        /* Check range of address */
    return ERR_RANGE;
  }
  *Data = readflash(Addr);             /* read data from FLASH */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_SetLongFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a long word to an address in FLASH. The operation of
**         this method depends on the "Write method" property and state
**         of the flash. Please see more details on general info page
**         of the help.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           16 bit word location in the selected memory
**                           space. The memory space depends on the
**                           selected flash memory device.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - The address is out of range 
**                           - ERR_VALUE - The read value is not equal
**                           to the written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetLongFlash(IFsh1_TAddress Addr,dword Data)
{
  register byte i;
  register bool SectorBackup;
  word data[2];
  word tmpData;

  Err = ERR_OK;
  if (OutOfRange(Addr, (Addr + 1U))) { /* Check range of address */
    return ERR_RANGE;
  }
  data[0]=(word)(Data);                /* Divide 32 bit data to two 16 bit words */
  data[1]=(word)(Data >> 16);
  SectorBackup = FALSE;                /* Initialize sector backup flag */
  for (i = 0U; i < 2U; i++) {          /* For both 16 bit data */
    while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
    if (((word)~(readflash(Addr+i)) & data[i]) != 0x00U) { /* Is a sector erasure necessary? */
      BackupSector(Addr + i);          /* Backup sector */
      SectorBackup = TRUE;             /* Set sector backup flag */
      procflash(((Addr+i) & 0xFFFFFFFCU), 0U, PAGE_ERASE); /* Erase the sector */
      while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
      if (Err != ERR_OK) {             /* If an error occured then exit */
        return Err;
      }
    }
    if (SectorBackup) {
      BackupArray[BackupArrayAddr(Addr+i)] = data[i]; /* Write new data to buffer */
      if ((i == 1U) || (((Addr + 1U) & (SectorSize(Addr)-1U)) == 0x00U)) { /* If all data were written or the long data overrun the sector border */
        Err = RestoreSector(Addr + i); /* Restore sector */
        if (Err != ERR_OK) {           /* If an error occured then exit */
          return Err;
        }
        SectorBackup = FALSE;          /* Clear sector backup flag */
      }
    } else {
      if (((Addr+i) & 0x01U) == 0x00U) {
        tmpData = readflash((Addr+i) + 1U);
        procflash((Addr+i), (dword)(((dword)tmpData << 16) | data[i]), PROGRAM); /* Write new data to Flash */
      } else {
        tmpData = readflash((Addr+i) - 1U);
        procflash(((Addr+i) - 1U), (dword)(tmpData  | ((dword)data[i] << 16)), PROGRAM); /* Write new data to Flash */
      }
      if (Err != ERR_OK) {             /* If an error occured then exit */
        return Err;
      }
    }
  }
  while(getRegBit(FTFL_FSTAT, CCIF) == 0x00U){} /* Wait to command complete */
  if (Err == ERR_OK) {
    if (readflash(Addr) != data[0]) {  /* If the read lower word is not equal to written then exit */
      return ERR_VALUE;
    }
    if (readflash((Addr + 1U)) != data[1]) { /* If the read higher word is not equal to written then exit */
      return ERR_VALUE;
    }
  }
  EnWriteEnd = TRUE;                   /* Enable call WriteEnd event */
  setReg8Bit(FTFL_FCNFG, CCIE);        /* Enable interrupt */
  return Err;
}

/*
** ===================================================================
**     Method      :  IFsh1_GetLongFlash (component IntFLASH)
*/
/*!
**     @brief
**         Gets a long word from an address in FLASH.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           16 bit word location in the selected memory
**                           space. The memory space depends on the
**                           selected flash memory device.
**     @param
**         Data            - A pointer to the returned 32-bit data.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - The address is out of range 
**                           - ERR_BUSY - Device is busy
*/
/* ===================================================================*/
byte IFsh1_GetLongFlash(IFsh1_TAddress Addr,dword *Data)
{
  if (OutOfRange((Addr+1U), (Addr+1U))) { /* Check range of address */
    return ERR_RANGE;
  }
  *Data = (dword)readflash(Addr) | (((dword)(readflash(Addr+1U)))<<16); /* Read data from FLASH */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_Init (component IntFLASH)
**
**     Description :
**         Initializes the associated peripheral(s) and the components 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void IFsh1_Init(void)
{
  EnEvent = TRUE;                      /* Enable events */
  EnWriteEnd = FALSE;                  /* Initialize calling write end events flag */
  /* FTFL_FCNFG: CCIE=0,RDCOLLIE=1,ERSAREQ=0,ERSSUSP=0,??=0,PFLSH=0,RAMRDY=0,EEERDY=0 */
  setReg8Bit(FTFL_FCNFG, RDCOLLIE);    /* Enable read collision interrupt */
  /* Copy FLASH process routine to program RAM. All program or erase processes will be launched and wait for their end in this routine */
  mempcpy(((dword)&_LWIR_ROM_addr_high<<16)+(dword)&_LWIR_ROM_addr_low, ((dword)&_LWIR_RAM_addr_high<<16)+(dword)&_LWIR_RAM_addr_low, (word)(dword)&_LWIR_size);
}

/*
** ===================================================================
**     Method      :  IFsh1_CommandCompleteInterrupt (component IntFLASH)
**
**     Description :
**         The method services the interrupt of the selected peripheral(s)
**         and eventually invokes the components event(s).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma interrupt alignsp saveall
void IFsh1_CommandCompleteInterrupt(void)
{
  register byte StatusReg;

  StatusReg = getReg8(FTFL_FSTAT);     /* Get status reg. values */
  clrReg8Bit(FTFL_FCNFG, CCIE);        /* Disable command complete interrupt */
  if ((StatusReg & (FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_FPVIOL_MASK)) != 0x00U) {
    setReg8(FTFL_FSTAT, (FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_FPVIOL_MASK)); /* Clear error interrupt flags */
    Err = ERR_NOTAVAIL;                /* Set error value to be returned by process function */
    if ((StatusReg & FTFL_FSTAT_FPVIOL_MASK) != 0x00U) {
      Err = ERR_PROTECT;               /* Set error value to be returned by process function */
    }
  } else {
    if (EnWriteEnd) {
      EnWriteEnd = FALSE;              /* Disable call WriteEnd event */
      if (EnEvent) {
        IFsh1_OnWriteEnd();            /* Invoke user event */
      }
    }
  }
}

/*
** ===================================================================
**     Method      :  IFsh1_ReadCollisionErrorInterrupt (component IntFLASH)
**
**     Description :
**         The method services the interrupt of the selected peripheral(s)
**         and eventually invokes the components event(s).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma interrupt alignsp saveall
void IFsh1_ReadCollisionErrorInterrupt(void)
{
  Err = ERR_NOTAVAIL;                  /* Set error value to be returned by process function */
  setReg8(FTFL_FSTAT, FTFL_FSTAT_RDCOLERR_MASK); /* Clear read collision error interrupt flag */
}

/*
** ===================================================================
**     Method      :  IFsh1_DataPtr2Addr (component IntFLASH)
*/
/*!
**     @brief
**         This method converts data pointer to format of a component's
**         method address parameter. Generally a data pointer format is
**         different from format of a method Addr parameter.
**     @param
**         Addr            - Data pointer.
**     @return
**                         - Address in the format used in the component
**                           methods.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The return value is address of a byte
**                           location of the object the input parameter
**                           - pointer pointing at (address of a 16 bit
**                           word location multiplied by 2 and the least
**                           significant bit determines even or odd byte).
*/
/* ===================================================================*/
/*
IFsh1_TAddress IFsh1_DataPtr2Addr(void DataPtr)

**  This method is implemented as a macro. See IFsh1.h file.  **
*/

/*
** ===================================================================
**     Method      :  IFsh1_FuncPtr2Addr (component IntFLASH)
*/
/*!
**     @brief
**         This method converts function pointer to format of a
**         component's method address parameter. Generally a function
**         pointer format is different from format of a method Addr
**         parameter.
**     @param
**         Addr            - Function pointer.
**     @return
**                         - Address in the format used in the component
**                           methods.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The return value is address of a byte
**                           location of the object the input parameter
**                           - pointer pointing at (address of a 16 bit
**                           word location multiplied by 2 and the least
**                           significant bit determines even or odd byte).
*/
/* ===================================================================*/
/*
IFsh1_TAddress IFsh1_FuncPtr2Addr(void FuncPtr)

**  This method is implemented as a macro. See IFsh1.h file.  **
*/

/* END IFsh1. */
/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
